<!doctype html>
<html>

<head>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script src="/socket.io/socket.io.js"></script>
</head>

<body>

  <div>
    <svg version=1.1 width=1000 height=1000 id=viewport style='border:2px solid blue;'>
    </svg>

    <svg version=1.1 width=500 height=500 id=map style=''>
      <circle id=observer cx=100 cy=100 r=10 stroke=blue fill=green stroke-width=3px />
      <line class=direction id=direction x1=100 y1=100 x2=150 y2=100 stroke-width=3px stroke=blue />
    </svg>
  </div>

  <div id=level
    style="position:absolute; top:0px; left:1100px; height:100px; width:400px; background:#ccc; font-size:50pt; text-align:center">
    Level 1
  </div>
  <div id=luke-div
    style="position:absolute; top:800px; left:1100px; height:100px; width:400px; font-size:20pt; text-align:center">
  </div>
  <div id=dashboard
    style="position:absolute; top:125px; left:1200px; height:100px; width:100px; font-size:20pt; text-align:center">
    <svg version=1.1 width=100 height=100 id=direction>
      <line id=direction-arrow x1=50 x2=75 y1=50 y2=50 stroke="black" stroke-width=2 />
      <circle id=direction-center cx=50 cy=50 r=5 fill=#000 />
    </svg>
  </div>
  <div id=closeness
    style="position:absolute; top:125px; left:1300px; width:100px; height:100px; background-color:green;">&nbsp;</div>

  <div id=gamestatus
    style="position:absolute; top:250px; left:1100px; width:400px; height:250px; background-color:#aaa">
    &nbsp;
  </div>


</body>

<script>
  let socket = io();

  let MAZE_HEIGHT = 7;
  let MAZE_WIDTH = 7;
  let LEVEL = 3
  let MAX_LEVEL = Infinity;

  let VISION_ANGLE_VERTICAL = 45 / 360 * (2 * Math.PI);
  let VISION_ANGLE_HORIZONTAL = 45 / 360 * (2 * Math.PI);
  let VISION_HEIGHT = 1000;
  let VISION_WIDTH = 1000;

  let PLAYER_ID = -1;

  let freeze = false;

  username = "";

  let dead_ends = undefined;
  let maze = undefined;
  player_list = [];

  let stick_person = [
    [0, 290],
    [15, 285],
    [30, 230],
    [57, 175],
    [57, 75],
    [50, 75],
    [45, 125],
    [5, 155],
    [45, 125],
    [50, 75],
    [57, 75],
    [73, 75],
    [80, 75],
    [135, 115],
    [135, 120],
    [85, 135],
    [135, 120],
    [135, 115],
    [80, 75],
    [57, 75],
    [30, 55],
    [30, 20],
    [65, 0],
    [100, 20],
    [100, 55],
    [73, 75],
    [73, 175],
    [90, 230],
    [115, 285],
    [95, 290]];


  function calculate_polar_coordinates(observer, x1, y1, z1) {
    x = observer.x
    y = observer.y
    z = observer.z
    theta = observer.direction_rad

    horizontal_distance = Math.sqrt((x - x1) ** 2 + (y - y1) ** 2);

    let sin_val_h = (x1 - x) / horizontal_distance;
    if (sin_val_h > 1) sin_val_h = 1;
    if (sin_val_h < -1) sin_val_h = -1;
    horizontal_angle = Math.asin(sin_val_h);

    if (y < y1) {
      horizontal_angle = Math.PI - horizontal_angle;
    }

    vertical_distance = Math.sqrt(horizontal_distance ** 2 + (z - z1) ** 2);

    let sin_val_v = (z - z1) / vertical_distance;
    if (sin_val_v > 1) sin_val_v = 1;
    if (sin_val_v < -1) sin_val_v = -1;
    vertical_angle = Math.asin(sin_val_v);

    return [horizontal_angle, vertical_angle];
  }

  rendered_map = false;
  function show_map(observer, walls) {


    if (!rendered_map) {
      console.log("setting user token color", observer.color);
      $("#observer").attr("fill", observer.color);

      dead_ends.forEach((p) => {
        x = p[1];
        y = p[0];
        map.append(`<rect class=mapfill x=${x * 20 + 3} y=${y * 20 + 3} width=14 height=14 fill="#ffd" />`);
      })

      map = $("#map");
      map.find(".mapwall").remove();
      map.find(".mapfill").remove();

      for (i = 0; i < walls.length; i++) {
        wall = walls[i];
        d = `M ${wall.x1} ${wall.y1}, ${wall.x2} ${wall.y2}`
        map.append(`<path class=mapwall id="mapwall${i}" d="${d}" stroke="${wall.color}" stroke-width="5px"></path>`);
      }
      rendered_map = true;

      for (y = 0; y < maze.length; y++) {
        for (x = 0; x < maze[y].length; x++) {
          if (maze[y][x].present) {
            map.append(`<rect class=mapfill x=${x * 20} y=${y * 20} width=20 height=20 fill="#777"/>`);
          }
        }
      }

      update_map(1, 1);
      maze[1][1].explored = true;
      maze[1][1].onmap = true;
    }

    $("#observer").attr("cx", observer.x);
    $("#observer").attr("cy", observer.y);
    $("#direction").attr("x1", observer.x);
    $("#direction").attr("y1", observer.y);
    $("#direction").attr("x2", observer.x + Math.sin(observer.direction_rad) * 10);
    $("#direction").attr("y2", observer.y - Math.cos(observer.direction_rad) * 10);

    document.getElementById("map").innerHTML += "";
  }

  function show_players_on_map(player_list) {
    console.log("in show_players_on_map:", map);
    map.find(".players").remove()
    for (let i = 0; i < player_list.length; i++) {
      if (player_list[i].id !== PLAYER_ID && player_list[i].level === LEVEL) {
        map.append(`<circle class=players cx=${player_list[i]['position-x']} cy=${player_list[i]['position-y']} r=10 fill=${player_list[i].color} />`);
      }
    }
    document.getElementById("map").innerHTML += "";
  }

  function update_map(y, x) {
    map = $("#map");
    map.append(`<rect class=mapfill x=${x * 20} y=${y * 20} width=20 height=20 fill-opacity=.5 fill="#8f8"/>`);
  }

  function show(observer, walls, wallid) {
    angle_c1 = calculate_polar_coordinates(observer, walls[wallid].x1, walls[wallid].y1, walls[wallid].z1);
    angle_c2 = calculate_polar_coordinates(observer, walls[wallid].x2, walls[wallid].y2, walls[wallid].z1);
    angle_c3 = calculate_polar_coordinates(observer, walls[wallid].x2, walls[wallid].y2, walls[wallid].z2);
    angle_c4 = calculate_polar_coordinates(observer, walls[wallid].x1, walls[wallid].y1, walls[wallid].z2);

    corners = [];

    wall_is_visible = false;
    wall_is_left = false;
    wall_is_right = false;
    angle_sum = 0;
    for (i = 0; i < 4; i++) {
      angle = [angle_c1, angle_c2, angle_c3, angle_c4][i];
      angle0 = angle[0];

      angle[0] = (angle[0] - observer.direction_rad);

      angle[0] = ((((angle[0]) % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2));
      if (angle[0] > Math.PI) {
        angle[0] = angle[0] - Math.PI * 2;
      }
      angle_sum += Math.abs(angle[0]);

      x = (angle[0] / VISION_ANGLE_HORIZONTAL) * VISION_WIDTH + VISION_WIDTH / 2;
      y = (angle[1] / VISION_ANGLE_VERTICAL) * VISION_HEIGHT + VISION_HEIGHT / 2;

      corners.push([x.toFixed(0), y.toFixed(0)]);
    }
    wall_is_visible = (angle_sum < Math.PI * 2);
    rendered_wall = $("#" + `myline${wallid}`);
    distance = walls[wallid].distance;
    if (wall_is_visible == true) {
      wall = `M ${corners[0][0]} ${corners[0][1]}`;
      for (i = 1; i < 4; i++) {
        wall = wall.concat(`, ${corners[i][0]} ${corners[i][1]}`);
      }

      console.log("show:", wallid, "x", (walls[wallid].x1 + walls[wallid].x2) / 2, "y", (walls[wallid].y1 + walls[wallid].y2) / 2, "dist", distance, corners);
      wall += ' Z';

      if (rendered_wall.length == 0) {
        console.log("wall length is 0");
        $("#viewport").append(`<path id=myline${wallid} d="${wall}" stroke=black stroke-width=5px fill=${walls[wallid].color}\>`);
      } else {
        console.log("wall length is not 0");
        $("#" + `myline${wallid}`).attr("d", wall);
        $("#" + `myline${wallid}`).attr("fill", walls[wallid].color);
        $("#" + `myline${wallid}`).attr("stroke-width", "5px");
      }
    } else {
      if (rendered_wall.length == 0) {
        wall = "M 100 100, 200, 100, 100,200";
        $("#viewport").append(`<path id=myline${wallid} d="${wall}" stroke=black stroke-width=0px fill=transparent\>`);
      } else {
        $("#" + `myline${wallid}`).attr("fill", "transparent");
        $("#" + `myline${wallid}`).attr("stroke-width", "0px");
      }
    }
    $("#" + `myline${wallid}`).attr("distance", `${distance}`);
    walls[wallid].id = wallid;
  };


  function cheat_code_statemachine(key) {

    // handle cheat codes
    if (key == map_phrase[map_phrase_char]) {
      map_phrase_char += 1;
    } else if ((map_phrase_char >= 1) && (key == map_phrase[map_phrase_char - 1])) {
      // stay the same
    } else {
      map_phrase_char = 0;
    }

    if (map_phrase_char >= map_phrase.length) {
      $("#map").css("display", "inline")
      map_phrase_char = 0;
    }

    if (key == freeze_phrase[freeze_phrase_char]) {
      freeze_phrase_char += 1;
      console.log("getting cold", freeze_phrase_char);
    } if ((freeze_phrase_char >= 1) && (key == freeze_phrase[freeze_phrase_char - 1])) {
      // stay the same
    } else {
      freeze_phrase_char = 0;
    }
    if (freeze_phrase_char >= freeze_phrase.length) {
      console.log("wrap up warm baby");
      socket.emit("maze", { "type": "power up", "powerUpType": "freeze_bomb", "duration": 5 });
      freeze_phrase_char = 0;
    }

    if (key == restart_phrase[restart_phrase_char]) {
      restart_phrase_char += 1;
      console.log("i feel a distance growing between us", restart_phrase_char);
    } if ((restart_phrase_char >= 1) && (key == restart_phrase[restart_phrase_char - 1])) {
      // stay the same
    } else {
      restart_phrase_char = 0;
    }
    if (restart_phrase_char >= restart_phrase.length) {
      console.log("see you later");
      socket.emit("maze", { "type": "power up", "powerUpType": "restart" });
      restart_phrase_char = 0;
    }

    console.log(map_phrase_char, restart_phrase_char, freeze_phrase_char);
  }


  function valid_position(maze, y, x) {
    let ypos = Math.floor(y / 20, 0);
    let top = Math.floor((y - 5) / 20, 0);
    let bot = Math.floor((y + 5) / 20, 0);
    let xpos = Math.floor(x / 20, 0);
    let left = Math.floor((x - 5) / 20, 0);
    let right = Math.floor((x + 5) / 20, 0);

    if (maze[ypos][xpos].present ||
      maze[bot][left].present ||
      maze[bot][right].present ||
      maze[top][left].present ||
      maze[top][right].present) {

      return false;
    } else {
      return true;
    }
  }

  let map_phrase_char = 0;
  let map_phrase = "dad4tw";
  let freeze_phrase_char = 0;
  let freeze_phrase = "freeze";
  let restart_phrase_char = 0;
  let restart_phrase = "buhbye";
  let waiting_for_server = false;


  let MOVE_DISTANCE = 10;
  let KEY_REPEAT_DELAY = 10;

  function update_position(event) {
    if (waiting_for_server) return true;

    // Use local variables to calculate PROPOSED new position/direction
    let next_x = observer.x;
    let next_y = observer.y;
    let next_direction_rad = observer.direction_rad;

    let shift = event.originalEvent.shiftKey;

    if (freeze) {
      return false;
    }

    // calculate new position based on key used.
    if (event.originalEvent.key == "ArrowRight") {
      if (shift) {
        next_x += Math.cos(next_direction_rad) * MOVE_DISTANCE;
        next_y += Math.sin(next_direction_rad) * MOVE_DISTANCE;
      } else {
        next_direction_rad += Math.PI / 6
        // KEY_REPEAT_DELAY needs to be handled cautiously, but keeping legacy behavior for now
        KEY_REPEAT_DELAY = 500;
      }
    }
    if (event.originalEvent.key == "ArrowLeft") {
      if (shift) {
        next_x -= Math.cos(next_direction_rad) * MOVE_DISTANCE;
        next_y -= Math.sin(next_direction_rad) * MOVE_DISTANCE;
      } else {
        next_direction_rad -= Math.PI / 6
        KEY_REPEAT_DELAY = 500;
      }
    }
    if (event.originalEvent.key == "ArrowUp") {
      next_x += Math.sin(next_direction_rad) * MOVE_DISTANCE;
      next_y -= Math.cos(next_direction_rad) * MOVE_DISTANCE;
    }
    if (event.originalEvent.key == "ArrowDown") {
      next_x -= Math.sin(next_direction_rad) * MOVE_DISTANCE;
      next_y += Math.cos(next_direction_rad) * MOVE_DISTANCE;
    }

    if (next_direction_rad == observer.direction_rad && next_x === observer.x && next_y === observer.y) {
      return false; // No change
    }

    // correct for moving outside maze area
    next_y = Math.min((maze.length - 1) * 20, next_y);
    next_x = Math.min((maze[0].length - 1) * 20, next_x);

    // correct for collision with walls (Client-side prediction check)
    if (!valid_position(maze, next_y, next_x)) {
      // Logic from original: slide along walls if possible
      // But for server authority, simple rejection or partial movement is easier.
      // Keeping original sliding logic but calculating against PREVIOUS (current) x/y

      let can_slide_x = false;
      let can_slide_y = false;

      // Try keeping X (sliding Y)
      if (valid_position(maze, next_y, observer.x) &&
        !((Math.round((next_direction_rad % Math.PI) / (Math.PI / 2))) % 2)) {
        next_x = observer.x;
        can_slide_y = true;
      }
      // Try keeping Y (sliding X)
      else if (valid_position(maze, observer.y, next_x) &&
        ((Math.round((next_direction_rad % Math.PI) / (Math.PI / 2))) % 2)) {
        next_y = observer.y;
        can_slide_x = true;
      } else {
        // Blocked completely
        next_x = observer.x;
        next_y = observer.y;
      }
    }

    // correct for collision with other players
    let other_player_in_position = false;
    player_list.forEach(
      (p, indx) => {
        if ((Math.abs(next_x - p['position-x']) < 10) &&
          (Math.abs(next_y - p['position-y']) < 10) &&
          (p.level == LEVEL) &&
          (p.id != PLAYER_ID)
        ) {
          other_player_in_position = true;
        }
      }
    );

    if (other_player_in_position) {
      next_x = observer.x;
      next_y = observer.y;
      console.log("bump!");
    }

    // If after collision checks we are still at start, return true (consumed) but don't emit
    if (next_x === observer.x && next_y === observer.y && next_direction_rad === observer.direction_rad) {
      return true;
    }

    // Proposed move is valid and different. Emit to server.
    waiting_for_server = true;
    socket.emit("maze",
      {
        "type": "user move",
        "x": next_x, // Sending PROPOSED next coordinate
        "y": next_y,
        "key": event.originalEvent.key, // Server might still use key for rotation logic or logging
        "shift": shift,
      },
      user_move_callback
    );

    return true;
  }

  function user_move_callback(data) {
    let server_observer = data.observer;
    waiting_for_server = false;

    // Update local observer with server state
    observer.x = server_observer.x;
    observer.y = server_observer.y;
    observer.direction_rad = server_observer.direction_rad;
    observer['position-x'] = server_observer.x;
    observer['position-y'] = server_observer.y;

    // Update slug trail (moved from update_position)
    let grid_x = Math.floor(observer.x / 20);
    let grid_y = Math.floor(observer.y / 20);

    if (grid_x >= 0 && grid_x < MAZE_WIDTH && grid_y >= 0 && grid_y < MAZE_HEIGHT) {
      if (!maze[grid_y][grid_x].explored) {
        maze[grid_y][grid_x].explored = true;
        if (!maze[grid_y][grid_x].onmap) {
          maze[grid_y][grid_x].onmap = true;
          update_map(grid_y, grid_x);
        }
      }
    }

    // Check dead ends (moved from update_position)
    let in_dead_end = false;
    let was_in_dead_end = false;
    dead_ends.forEach((position) => {
      let yt = position[0];
      let xt = position[1];
      // Using server coords
      if (xt * 20 < observer.x && (xt + 1) * 20 > observer.x &&
        yt * 20 < observer.y && (yt + 1) * 20 > observer.y) {
        $("#map").css("display", "inline");
        in_dead_end = true;
      }
    });
    // Simplified map display logic for brevity/robustness
    if (in_dead_end) {
      $("#map").css("display", "inline");
      setTimeout(() => $("#map").css("display", "none"), 2500);
    }

    // Check level complete
    if (observer.x > (MAZE_WIDTH - 2) * 20 && observer.y > (MAZE_HEIGHT - 2) * 20) {
      next_level();
    }

    show_all(observer, walls, maze);
  }

  function move(event) {

    if (update_position(event)) {
      show_all(observer, walls, maze);
      // reset state machines
      restart_phrase_char = 0;
      map_phrase_char = 0;
      freeze_phrase_char = 0;

      // auto repeat key press
      setTimeout(
        () => {
          if (is_key_down(event.originalEvent.key)) {
            move(event);
          }
        },
        KEY_REPEAT_DELAY
      );

    } else {
      cheat_code_statemachine(event.originalEvent.key);
    }

  }

  function show_player_on_viewport(observer, person, i) {

    let data_string = "M ";
    let personId = i;

    let angle_c1 = calculate_polar_coordinates(observer, person['position-x'], person['position-y'], 0);
    let angle_c2 = calculate_polar_coordinates(observer, person['position-x'], person['position-y'], 15);

    angle = angle_c1[0] - observer.direction_rad
    angle = ((angle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
    if (angle > Math.PI) {
      angle = angle - Math.PI * 2;
    }

    let x1 = (angle / VISION_ANGLE_HORIZONTAL) * VISION_WIDTH + VISION_WIDTH / 2;
    let y1 = (angle_c1[1] / VISION_ANGLE_VERTICAL) * VISION_HEIGHT + VISION_HEIGHT / 2;

    let x2 = (angle / VISION_ANGLE_HORIZONTAL) * VISION_WIDTH + VISION_WIDTH / 2;
    let y2 = (angle_c2[1] / VISION_ANGLE_VERTICAL) * VISION_HEIGHT + VISION_HEIGHT / 2;

    let height = (y1 - y2)
    let scale = height / 290;
    let xAdj = (x1 - 67.5 * scale);
    let yAdj = (y1 + y2) / 2 - 145 * scale;

    stick_person.forEach((d, indx) => data_string += `${d[0] * scale + xAdj} ${d[1] * scale + yAdj}${indx === stick_person.length - 1 ? "" : ", "}`);
    let renderedPerson = $(`#person${personId}`);

    if (renderedPerson.length == 0) {
      $("#viewport").append(`<path id=person${personId} d="${data_string}" stroke=${person.color} fill=none stroke-width=${16 * scale}px \>`);
    } else {
      $("#" + `person${personId}`).attr("d", data_string);
      $("#" + `person${personId}`).attr("stroke", person.color);
      $("#" + `person${personId}`).attr("stroke-width", `${16 * scale}px`);
    }

    document.getElementById("viewport").innerHTML += "";
  }

  function show_all(observer, walls, maze) {

    for (let i = 0; i < walls.length; i++) {
      walls[i].distance = (walls[i].x - observer.x) ** 2 + (walls[i].y - observer.y) ** 2;
    }

    walls.sort((a, b) => a.distance < b.distance ? 1 : a.distance > b.distance ? -1 : 0);
    console.log("show_all: walls.length", walls.length)

    for (let i = 0; i < walls.length; i++) {
      show(observer, walls, i);
    }

    player_list.forEach((p, i) => {
      if (p.id != PLAYER_ID && p.level == LEVEL) {
        show_player_on_viewport(observer, p, i);
      }
    });

    show_map(observer, walls, maze);
    document.getElementById("viewport").innerHTML += "";


    //distance = ((MAZE_WIDTH - observer.x/20)**2 + (MAZE_HEIGHT - observer.y/20)**2) / (MAZE_WIDTH**2 + MAZE_HEIGHT**2)
    distance = (MAZE_HEIGHT - observer.y / 20 + MAZE_WIDTH - observer.x / 20) / (MAZE_HEIGHT + MAZE_WIDTH)
    update_dashboard(observer.direction_rad, distance);
  }

  function update_dashboard(direction, distance) {
    $("#direction-arrow").attr("x2", 50 + Math.sin(direction) * 25);
    $("#direction-arrow").attr("y2", 50 - Math.cos(direction) * 25);

    blue = Math.round(distance * 255).toString(16);
    red = (255 - Math.round(distance * 255)).toString(16);

    $("#closeness").css("background-color", `#${red}00${blue}`);
  }

  function get_first_maze(username) {
    socket.emit('maze', { "type": "new maze", "level": LEVEL, "user": username }, get_maze_callback);
    $("body").on("keydown", move)
  }

  function get_next_maze(username) {
    socket.emit('maze', { "type": "new maze", "level": LEVEL, "user": username }, get_maze_callback);
  }

  function countdown(remainingTime) {
    console.log("countdown", remainingTime);

    if ($("#countdown").length == 0) {
      $("body").append("<div id=countdown style='position:absolute; left:300px; top:300px; font-size:400pt;'>" + remainingTime + "</div>");
    } else {
      $("#countdown").html(remainingTime);
    }

    if (remainingTime == 0) {
      freeze = false;
      $("#countdown").remove();
    } else {
      setTimeout(() => { countdown(remainingTime - 1); }, 1000);
    }
  }

  function get_maze_callback(game_data, new_maze, new_dead_ends, player) {

    if (!game_data.success) {
      console.log("get_maze_callback game_data=", game_data, player);
      createStartForm();
      return;
    }

    $("#sky").remove();
    $("#ground").remove();

    $("#viewport").prepend(`<path id=ground d="M 0 1000, 1000 1000, 1000 500,  0 500" fill='#4f4' />`);
    $("#viewport").prepend(`<path id=sky d="M 0 0, 1000 0, 1000 500,  0 500" fill='#aaf' />`);

    MAX_LEVEL = game_data.max_level;
    PLAYER_ID = player.id;

    freeze = true;
    if (LEVEL === 0) {
      countdown(1);
    } else {
      countdown(3);
    }

    console.log("maze message received", new_maze, new_dead_ends);
    observer.color = player.color;
    maze = new_maze;
    dead_ends = new_dead_ends;

    MAZE_HEIGHT = maze.length;
    MAZE_WIDTH = maze[0].length;
    walls = maze_to_walls(maze);
    if (player.state === "playing") {
      observer = { x: 30, y: 30, z: 15, direction_rad: Math.PI * 8 / 16, color: player.color, level: LEVEL };
    }
    rendered_map = false;

    $("#myline1").attr("fill", "orange");
    show_all(observer, walls, maze);
    $("#map").css("display", "inline")
  }

  function maze_to_walls(maze) {
    walls = [];
    wall_height = 20;
    grid_size = 20;
    for (y = 0; y < MAZE_HEIGHT; y++) {
      for (x = 0; x < MAZE_WIDTH; x++) {

        if (x > MAZE_HEIGHT / 2) {
          if (y > MAZE_HEIGHT / 2) {
            wallColors = ["#800", "#822", "#a22", "#a00"];
          } else {
            wallColors = ["#fb4", "#fa2", "#f81", "#f51"];
          }
        } else {
          if (y > MAZE_HEIGHT / 2) {
            wallColors = ["#795695", "#371576", "#AC94f4", "#643b9f"];
          } else {
            wallColors = ["#008", "#228", "#22a", "#00a"];
          }
        }

        if (maze[y][x].present) {
          if (x + 1 < MAZE_WIDTH && !maze[y][x + 1].present) {
            walls.push({ x1: (x + 1) * grid_size, x2: (x + 1) * grid_size, y1: y * grid_size, y2: (y + 1) * grid_size, z1: 0, z2: wall_height, color: wallColors[0] });
          }
          if (x - 1 > 0 && !maze[y][x - 1].present) {
            walls.push({ x1: x * grid_size, x2: x * grid_size, y1: y * grid_size, y2: (y + 1) * grid_size, z1: 0, z2: wall_height, color: wallColors[1] });
          }
          if (y + 1 < MAZE_HEIGHT && !maze[y + 1][x].present) {
            walls.push({ x1: x * grid_size, x2: (x + 1) * grid_size, y1: (y + 1) * grid_size, y2: (y + 1) * grid_size, z1: 0, z2: wall_height, color: wallColors[2] });
          }
          if (y - 1 > 0 && !maze[y - 1][x].present) {
            walls.push({ x1: x * grid_size, x2: (x + 1) * grid_size, y1: y * grid_size, y2: y * grid_size, z1: 0, z2: wall_height, color: wallColors[3] });
          }
        }
      }
    }

    for (i = 0; i < walls.length; i++) {
      walls[i].x = Math.round((walls[i].x1 + walls[i].x2) / 2);
      walls[i].y = Math.round((walls[i].y1 + walls[i].y2) / 2);
    }

    return walls;
  }

  function make_test_walls() {
    walls = [
      { x1: 150, y1: 0, x2: 350, y2: 0, z1: 0, z2: 100, color: "red" },
      /*{ x1:50, y1:150, x2:50, y2:350, z1:0, z2:100, color:"blue" },
      { x1:450, y1:150, x2:450, y2:350, z1:0, z2:100, color:"green" }
      */
      { x1: 150, y1: 500, x2: 350, y2: 500, z1: 0, z2: 100, color: "yellow" },
    ]
    return walls;
  }


  maze = [];
  walls = [];
  dead_ends = [];
  observer = { x: 30, y: 30, z: 15, direction_rad: Math.PI * 8 / 16, level: LEVEL };

  debug = false;

  function next_level() {
    if (LEVEL + 1 >= MAX_LEVEL) {
      $("#map").css("display", "inline");
      if ($("#complete-banner").length === 0) {
        $("body").append("<div id='complete-banner' style='position:absolute; background-color:white; left:300px; top:300px; font-size:60pt; background-color:orange;'>Mission Complete<br><center><span style='font-size:20pt'>Press F5 to restart.</span></center></div>")
      }
    } else {
      LEVEL += 1;
      $("#viewport").empty()
      $("#viewport").prepend(`<path id=ground d="M 0 1000, 1000 1000, 1000 500,  0 500" fill='#4f4' />`);
      $("#viewport").prepend(`<path id=sky d="M 0 0, 1000 0, 1000 500,  0 500" fill='#aaf' />`);

      $("#level").html(`Level ${LEVEL + 1}`);
      rendered_map = false;
      get_next_maze(username);
    }
  }

  function createStartForm() {
    $("body").append("<div id=name-enter-dialog style='position:absolute; background-color:white; left:300px; top:300px; font-size:60pt; background-color:orange;'>Enter your name<br><center><span style='font-size:20pt'><form><input id=name></input><form></span></center></div>");
    $("#name").focus();

    $("#name-enter-dialog").on('submit', function (e) {
      let name = $("#name").val();
      if (name !== "") {
        username = name.substr(0, 20);
        $("#name-enter-dialog").remove();
        get_first_maze(name);
      }
    });

  }

  createStartForm();


  const is_key_down = (() => {
    const state = {};

    window.addEventListener('keyup', (e) => state[e.key] = false);
    window.addEventListener('keydown', (e) => state[e.key] = true);

    return (key) => state.hasOwnProperty(key) && state[key] || false;
  })();


  socket.on('player update', function (msg) {
    let table = "<table><tr><th>Player<th>Level<th>Completeness";

    player_list = []
    player = undefined;
    Object.entries(msg).forEach((obj) => {
      if (obj[1].name) {
        player_list.push(obj[1]);
      }
      if (obj[1].id == PLAYER_ID) {
        player = obj[1];
      }
    })

    console.log("player update", player);

    if (player) {
      if (player.state === 'frozen') {
        if (!freeze) {
          freeze = true;
          $("body").append("<div id='freeze-bomb-banner' style='position:absolute; background-color:white; left:300px; top:300px; font-size:60pt; background-color:orange;'> Freeze bomb! <br><center><span style='font-size:20pt'> Just chill for a few seconds </span></center></div>");
        }
      } else {
        if (freeze) {
          freeze = false;
          $("#freeze-bomb-banner").remove();
        }
      }

      if (player['position-x'] != observer['x'] || player['position-y'] != observer['y']) {
        console.log("posiiton change", observer, player);
        observer['x'] = player['position-x'];
        observer['y'] = player['position-y'];
        if (player['position-x'] === 30 && player['position-y'] === 30) {
          $("body").append("<div id='restart-banner' style='position:absolute; background-color:white; left:300px; top:300px; font-size:60pt; background-color:orange;'> Back to the start <br><center><span style='font-size:20pt'> </span></center></div>");
          setTimeout(() => { $("#restart-banner").remove() }, 2000);
        }
        show_all(observer, walls, maze);
      }
    }

    /*
    player_list.sort((a, b) => {
      return (a.level !== b.level) ? (b.level - a.level) : (b['position-x'] + b['position-y'] - a['position-x'] - a['position-y']);
    });
    */
    /* Player rendering moved to show_all */

    if (map) {

      console.log("calling show_players_on_map", map);

      show_players_on_map(player_list);
    }

    // Ensure we render the scene (including other players) even if our own position hasn't changed
    show_all(observer, walls, maze);

    player_list.forEach((obj) => {
      if (obj.name) {
        let level = obj.level + 1;
        let x = obj['position-x'];
        let y = obj['position-y'];
        let completeness = Math.floor((x + y) / ((2 * level + 5) * 2) * 5)

        if (obj.state === "playing") {
          table += `<tr style=background-color:${obj.color}><td>${obj.name}<td>${level}<td>${completeness}`;
        } else {
          positions = ["Champion", "Silver Medal", "Bronze Medal", "4th place", "5th place", "6th place"];
          table += `<tr style=background-color:${obj.color}><td>${obj.name}<td>Complete<td>${positions[obj.position]}`;
        }
      }
    });
    table += '</table>';
    $("#gamestatus").html(table);
  });

</script>

</html>